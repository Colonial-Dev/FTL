use std::sync::Arc;

pub use minijinja::{
    Error as MJError,
    ErrorKind as MJErrorKind
};
use minijinja::value::Value;

use crate::prelude::*;

/// Type alias for a Minijinja-compatible [`Result`].
pub type MJResult = Result<Value, MJError>;

/// Newtype used to smuggle [`eyre::Report`]s through MiniJinja.
#[derive(Debug, Clone)]
pub struct WrappedReport(Arc<Report>);

impl WrappedReport {
    pub fn extract(self) -> Report {
        match Arc::try_unwrap(self.0) {
            Ok(report) => report,
            Err(_) => {
                error!("Tried to extract a wrapped report, but we lack exclusive access.");
                eyre!("An internal error occurred.")
                    .note("If you're seeing this message, a bug has occurred in FTL's error handling.")
                    .suggestion("Consider reporting this issue.")
            }
        }
    }

    pub fn wrap(error: impl Into<Report>) -> MJError {
        let report = WrappedReport::from(error.into());

        MJError::new(
            MJErrorKind::UndefinedError,
            "An error occurred in FTL code."
        ).with_source(report)
    }

    pub fn flatten(root: MJError) -> Report {
        let mut root_err = &root as &dyn::std::error::Error;

        while let Some(next_err) = root_err.source() {
            if let Some(report) = next_err.downcast_ref::<WrappedReport>() {
                let message = format!(
                    "An error was encountered during template evaluation (in template file \"{}\" at line no. {}).",
                    root.name().unwrap_or("?"),
                    root.line().unwrap_or(0)
                );

                let report = report.clone();
                drop(root);
                
                return report.extract().wrap_err(message)
            }

            root_err = next_err;
        }

        Report::from(root)
            .wrap_err("An error was encountered during template evaluation.")
    }
}

impl From<Report> for WrappedReport {
    fn from(value: Report) -> Self {
        WrappedReport(Arc::new(value))
    }
}

impl std::fmt::Display for WrappedReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self.0)?;
        Ok(())
    }
}

impl std::error::Error for WrappedReport {}

#[cfg(test)]
mod test {
    use super::*;
    use minijinja::ErrorKind;

    #[test]
    fn error_flattening() {
        let internal_error = minijinja::Error::new(
            ErrorKind::UndefinedError,
            "An error was generated by non-FTL code."
        );

        let report: WrappedReport = eyre!("An Eyre Report generated by FTL code.").into();
        let erased_error = minijinja::Error::new(
            ErrorKind::UndefinedError,
            "An error was generated by FTL code and obfuscated by MiniJinja."
        ).with_source(report);

        let internal_flattened = WrappedReport::flatten(internal_error);
        let erased_flattened = WrappedReport::flatten(erased_error);

        assert_eq!(internal_flattened.to_string(), "An error was encountered during template evaluation.");
        assert_eq!(erased_flattened.to_string(), "An error was encountered during template evaluation (in template file \"?\" at line no. 0).");
    }
}
